поток – это легковесный про-цесс, набор исполняемых инструкций.
Практически все современ-ные ОС позволяют исполнять несколько 
таких наборов одновре-менно. Хотя одновременно – понятие относительное. 
Правильно было бы сказать  одновременно с точки зрения пользователя, 
ибо процессор один и исполнять он может только один набор инструк-ций 
Для создания  видимости одновременной работы процессор исполняет 
определенное количество инструкций од-ного потока, после чего 
переключается на другой. 
Это происходит очень часто, в результате чего создается иллюзия 
одновременной работы

Для чего это нужно? Современное программное обеспечение по большей 
часто асинхронно. Приложение ждет реакции пользо-вателя, ждет прихода 
данных по сети, ждет готовности устройства. Приложение ждет.
 Если вы посмотрите на загрузку процессора, то увидите, что чаще всего 99% 
времени он простаивает. Соответ-ственно, пока одна задача находится в 
стадии ожидания, можно заниматься другой.

Процесс  это задача операционной системы. У него собственное адресное 
пространство, с ним может быть проассоциировано несколько по-токов.
 Поток же  это гораздо более мелкая единица. Все потоки разделяют адресное
 пространство породившего их процесса и имеют доступ к одним данным.
Поскольку несколько потоков имеют доступ к одним данным, 
они их могут менять(возникнут проблемы).Для решения проблем и нужна синхронизация

Поток выполнения в Java представляется экземпляром класса Thread 
. Для того чтобы написать свой поток исполнения, необходимо наследоваться
 от этого класса и пе-реопределить метод run().Метод run() содержит действия,
 которые должны исполняться в новом потоке исполнения. Чтобы запустить его,
 необходимо со-здать экземпляр класса-наследника и вызвать наследованный
 ме-тод start(), который сообщает виртуальной машине, что необхо-димо 
запустить новый поток исполнения и начать в нем исполнять метод run().
После завершения run поток останавливается

Класс Thread содержит несколько методов для управления по-токами:
 getName()  получить имя потока;
 getPriority()  получить приоритет потока;
 isAlive()  определить, выполняется ли поток;
 join()  ожидать завершение потока;
 run()  запустить поток;(если вызвать без start будет выполнен в рассматриваемом потоке)
 sleep()  приостановить поток на заданное время;
 start()  запустить поток вызовом метода start().

поскольку в Java отсутствует множественное наследование, требование 
насле-доваться от Thread может привести конфликту. 
предлагается альтернативный способ созда-ния своего потока исполнения.
 Достаточно реализовать интерфейс Runnable, в котором объявлен только 
один метод – уже знакомый void run() 

наследование от Thread является более простым методом и используется в 
небольших приложенияъ( будет потомком), runneble более гибкий, но не может быть 
без thread


поток можно приостановить на определенный промежу-ток времени 
(изнутри самого этого потока), дав, таким образом, другим потокам выполнить
 свои задачи. Делается это через стати-ческий метод Thread, sleep() c 
параметром  количеством милли-секунд, на которое приостанавливается поток.
 До истечения этого времени поток может быть выведен из состояния ожидания
 вы-зовом interrupt

Статический метод yield() тоже служит для передачи управле-ния другим 
потокам: в результате его вызова происходит переклю-чение контекста и 
процессор начинает исполнять код другого по-тока.действует только на свой поток

Метод join() блокирует работу потока, в котором он вызван, до тех пор, 
пока не будет закончено выполнение вызывающего метод потока или не истечет
 время ожидания при обращении к методу join(long timeout).

Потоки в Java могу быть так называемыми демонами. Такой поток отличается
 от обычного тем, что он не препятствует оконча-нию работы виртуальной
 машины. Т.е. можно сказать, что вирту-альная машина работает, пока 
существует хотя бы один поток, не являющийся демоном. Потоки-демоны 
удобно использовать для фоновых задач.

Жизненный цикл
NEW  поток создан, но еще не запущен;
RUNNABLE  поток выполняется;
BLOCKED  поток блокирован;
WAITING  поток ждет окончания работы другого потока;
TIMEDWAITING  поток некоторое время ждет окончания другого потока;
TERMINATED  поток завершен

Получить значение состояния потока можно вызовом метода getState().
Поток переходит в состояние «неработоспособный» (WAITING) вызовом методов
 wait(), suspend() или методов ввода/вывода, которые предполагают задержку.
 Для задержки потока на некоторое время (в миллисекундах) можно пе-ревести
 его в режим ожидания (TIMEDWAITING) с помощью ме-тодов sleep(long millis)
 и wait(long timeout), при выполнении кото-рого может генерироваться
 прерывание InterruptedException.
Вернуть потоку работоспособность после вызова метода suspend() 
можно методом resume() (deprecated-метод), а после вы-зова метода wait()
 методами notify() или notifyAll().
 Поток перехо-дит в «пассивное» состояние (TERMINATED),
 если вызваны ме-тоды interrupt(), stop() (deprecated метод) или метод 
run() завершил выполнение. (не рекомендуется исползовать)

Нередко возникает ситуация, когда несколько потоков пытаются использо-вать
 общий ресурс и начинают мешать друг другу. 
Для контроли-рования процесса записи может использоваться разделение 
ре-сурса с применением ключевого слова synchronized.
Синхронизированный метод изолирует объект, после чего он становится 
недоступным для других потоков. Изоляция снима-ется, когда поток полностью 
выполнит соответствующий метод. Другой способ снятия изоляции — 
вызов метода wait() из изоли-рованного метода.