Интерфейс сообщает, какая одинаковая функциональность присуща
 реализующим его классам.
Interface "говорит": "Все классы, реализующие этот особый интерфейс
 будут иметь нечто общее". 
Поэтому, любой код, использующий interface знает, 
какой из методов может быть вызван для этого interface, впрочем, это все. 
Так что interface используется в качестве установления 
"протокола" между классами
Интерфейсы изолируют определение набора методов от иерархии наследования. 
Поскольку иерархия интерфейсов не совпадает с иерархией классов,
 классы, никак не связанные между собой в иерархии, 
могут реализовать один и тот же интерфейс или набор методов. 
Именно здесь возможности интерфейсов проявляются в наибольшей степени. 
Интерфейсы помогают повысить уровень абстракции.
Интерфейсы синтаксически подобны абстрактным классам, 
но в отличие от абстрактного класса содержат только константы 
(неизменяемые static final - поля) и объявления методов без их реализации. 
Перед ключевым словом interface может стоять только один модификатор
 public, означающий как и для класса, что интерфейс доступен отовсюду.
 Если же модификатора public нет, интерфейс доступен только в 
пределах своего пакета. 
Интерфейсы обладают своей собственной иерархией,
 не пересекающейся с классовой иерархией наследования.
 При этом, в отличие от классов, интерфейсы допускают множественное 
наследование. Именно в этом и заключается их главная особенность. 
В блоке описания интерфейса в любом порядке объявляются переменные
 и заголовки методов. Фактически все методы являются абстрактными,
 но модификатор abstract указывать не надо. 
Аналогично, все переменные являются static final полями 
Все константы и методы в интерфейсах всегда открыты, 
вне зависимости от указания модификатора public (прочие типы модификаторов управления доступом в интерфейсах недопустимы).
Интерфейсы размещаются в тех же пакетах и подпакетах, 
что и классы, и также компилируются в class-файлы.
Для того, чтобы использовать интерфейсы, от них должен быть унаследован 
класс, который реализует все абстрактные методы, определенные в интерфейсе.
Это можно сделать с помощью ключевого слова implements 
в заголовке объявления класса, после которого следует список интерфейсов,
 методы которых реализует данный класс (класс может реализовать методы нескольких интерфейсов). 
Особенности реализации интерфейсов:
 Методы, которые реализуют интерфейс, должны быть объявлены как public.
 Сигнатура типа реализующего метода должна точно соответствовать 
сигнатуре типа, указанной в определении интерфейса.
 Если класс включает интерфейс, но реализует не все его методы, 
то такой класс должен быть объявлен как абстрактный.
 Если класс реализует интерфейс, унаследованный от другого интерфейса,
 класс должен реализовать все методы, определенные в цепочке 
наследования интерфейсов.
Интерфейсы в основном целесообразно применять если различные классы,
 никак не связанные по иерархии классового наследования, 
должны реализовать некий общий набор методов. 
Что же лучше использовать: абстрактный класс или интерфейс? 
На этот вопрос нет однозначного ответа. 
Создавая абстрактный класс, вы волей-неволей  погружаете  его  в  иерархию
 классов, связанную условиями одиночного наследования и 
единым предком — классом Object. 
Пользуясь интерфейсами, вы можете свободно проектировать систему,
 не задумываясь об этих ограничениях. 
С другой стороны, в абстрактных классах можно сразу реализовать
 часть методов. Реализуя же интерфейсы, вы обречены на скучное
 переопределение всех методов. 
Начиная с Java 9, вы можете использовать приватные методы в интерфейсах.
 У них есть следующие особенности:у приватных методов есть тело, 
они не абстрактные 
они могут быть как статическими, так и нестатическими 
они не наследуются классами, реализующими интерфейс, и интерфейсами 
они могут вызывать другие методы интерфейса 
приватные методы могут вызывать другие приватные, 
абстрактные, статические методы или методы по умолчанию 
приватные статические методы могут вызывать только другие статические
 и приватные статические методы 
 Принцип разделения интерфейса / Четвертый принцип SOLID) 
призывает не создавать жирные универсальные интерфейсы. 
Вместо этого интерфейсы нужно разделять на более мелкие и 
специализированные, это поможет гибче их комбинировать в 
имплементирующих классах, не заставляя имплементировать лишние методы.
Ни один из объявленных методов не мо-жет быть реализован внутри интерфейса. 
В языке Java существует два вида интерфейсов: интерфейсы, 
определяющие функциональ-ность для классов посредством описания методов,
 но не их реали-зации; и интерфейсы, реализация которых автоматически 
придает классу определенные свойства. К последним относятся, например, 
интерфейсы Cloneable и Serializable, отвечающие за клонирование и 
сохранение объекта в информационном потоке соответственно.
Первый вид интерфейсов подобен классу, в котором все поля — константы 
(т.е. статические — static и неизменяемые — final), а все методы абстрактные.
Множественное наследо-вание между интерфейсами допустимо. 
Классы, в свою очередь, интерфейсы только реализуют. 
Класс может наследовать один суперкласс и реализовывать произвольное 
число интерфей-сов.